import "Utils.stg"
AsyncTableSharedMem(sync, name, keyType, valueType, dynamic, deltaType, aggrType, weightType, extraType, expr) ::= <<
package socialite.async.codegen;
<importForTable()>
//algorithm <name>
public class AsyncTable extends BaseAsyncTable{
    private static final Log L = LogFactory.getLog(AsyncTable.class);
    private volatile int size;
    private <KeyIndMap.(keyType)> keyIndMap;
    private <IndKeyMap.(keyType)> indKeyMap;
    private <PrimitiveObjectMap.(keyType)>\<<PrimitiveList.(keyType)>\> srcDstListMap; //if weight graph, src,[dst1, weight1 ,dst2, weight2]

    private <PrimitiveList.(valueType)> valueList;
    private List\<<TypeAtomic.(deltaType)>\> deltaList;
    <if(sync)>private List\<<TypeAtomic.(deltaType)>\> bufferDeltaList;<endif>

    <if(extraType)>private T<ShortTypeNameMap.(keyType)><ShortTypeNameMap.(extraType)>HashMap keyExtraMap;<endif>

    <if(IsBoolean.(valueType))> <!暂时忽略2-step程序的weight和extra!>
        private List\<Boolean> sentFlagList;
    <endif>

    <if(IsInt.(deltaType))>
    public static final <deltaType> IDENTITY_ELEMENT = <IntegerIdentityElement.(aggrType)>;
    <elseif(IsLong.(deltaType))>
    public static final <deltaType> IDENTITY_ELEMENT = <LongIdentityElement.(aggrType)>;
    <elseif(IsFloat.(deltaType))>
    public static final <deltaType> IDENTITY_ELEMENT = <FloatIdentityElement.(aggrType)>;
    <elseif(IsDouble.(deltaType))>
    public static final <deltaType> IDENTITY_ELEMENT = <DoubleIdentityElement.(aggrType)>;
    <endif>


    public AsyncTable(int initSize){
        keyIndMap = new <KeyIndMap.(keyType)>(initSize);
        indKeyMap = new <IndKeyMap.(keyType)>(initSize);
        valueList = new <PrimitiveList.(valueType)>(initSize);
        deltaList = new ArrayList\<>(initSize);
        srcDstListMap = new <PrimitiveObjectMap.(keyType)>(initSize);

        <if(sync)>bufferDeltaList = new ArrayList\<>(initSize);<endif>
        <if(IsBoolean.(valueType))>sentFlagList = new ArrayList\<>(initSize);<endif>
        <if(extraType)>keyExtraMap = T<ShortTypeNameMap.(keyType)><ShortTypeNameMap.(extraType)>HashMap(initSize);<endif>
    }

    @Override
    public boolean updateLockFree(int localInd<if(sync)>, int iter<endif>) {
        <deltaType> oldDelta;
        <if(IsBoolean.(valueType))>
            <if(sync)>
                if (iter % 2 == 0) {
                    oldDelta = deltaList.get(localInd).getAndSet(0);
                    oldDelta = bufferDeltaList.get(localInd).addAndGet(oldDelta);
                } else {
                    oldDelta = bufferDeltaList.get(localInd).getAndSet(0);
                    oldDelta = deltaList.get(localInd).addAndGet(oldDelta);
                }
            <else>
                oldDelta = deltaList.get(localInd).get();
            <endif>

            if (eval(oldDelta)){
                valueList.set(localInd, true);
            }

            if(valueList.get(localInd) && !sentFlagList.get(localInd)){
                <keyType> key = indKeyMap.get(localInd);

                <PrimitiveList.(keyType)> dstList = srcDstListMap.get(key);
                <! This node has no out-link, DO NOTHING !>
                if(dstList==null){

                } else {
                    <! 遍历每个邻接点 !>
                    synchronized(keyIndMap) {
                        for(int i = 0; i\< dstList.size(); i++) {
                            int dstLocalInd;
                            <keyType> dst = dstList.get(i);
                            if(keyIndMap.contains(dst)) {
                                dstLocalInd = keyIndMap.get(dst);
                            } else {
                                dstLocalInd = addEntry(dst, false, IDENTITY_ELEMENT);
                            }
                            
                            <! OTHER AGGREGATE FUNCTIONS IS NOT SUPPORTED !>
                            <if(sync)>
                                if (iter % 2 == 0) {
                                    <if(IsCount.(aggrType))>bufferDeltaList.get(adjacentLocalInd).addAndGet(1);<endif>
                                } else {
                                    <if(IsCount.(aggrType))>deltaList.get(adjacentLocalInd).addAndGet(1);<endif>
                                }
                            <else>
                                <if(IsCount.(aggrType))>deltaList.get(adjacentLocalInd).addAndGet(1);<endif>
                            <endif>
                        }
                    }
                }
                sentFlagList.set(localInd, true);
            }
        <else>
            <if(sync)>
            if (iter % 2 == 0) {
                oldDelta = deltaList.get(localInd).getAndSet(IDENTITY_ELEMENT);
            } else {
                oldDelta = bufferDeltaList.get(localInd).getAndSet(IDENTITY_ELEMENT);
            }
            <else>
                oldDelta = deltaList.get(localInd).getAndSet(IDENTITY_ELEMENT);
            <endif>

            if(oldDelta == IDENTITY_ELEMENT)
                return false;
            <! delta + value -> value !>
            <valueType> accumulatedValue = <WrappedType.(valueType)>.<AggrTypeFunc.(aggrType)>(valueList.get(localInd), oldDelta);
            <! 聚集后比原来还小，则不更新 !>
            <if(IsMax.(aggrType))>if(accumulatedValue \<= valueList.get(localInd))return false;
            <elseif(IsMin.(aggrType))>if(accumulatedValue >= valueList.get(localInd))return false;<endif>
            //更新value
            valueList.set(localInd, accumulatedValue);
            <!Count函数在不准与extra、weight同用，因为语义不明!>
            <if(extraType)><extraType> extra = extraList.get(localInd);<endif>
l
            <if(IsPairKey.(keyType))>List\<Pair><else><PrimitiveList.(keyType)><endif> adjacencies = adjacenciesList.get(localInd);
            <! 遍历每个邻接点 !>
            if(adjacencies == null) return true;
            for(int i = 0; i \< adjacencies.size(); i++){
                <if(IsCount.(aggrType))>
                <valueType> newDelta=oldDelta;
                <else>
                <valueType> newDelta = eval(oldDelta <if(weightType)>, weights.get(i)<endif> <if(extraType)>, extra<endif>);
                <endif>
                int adjacentLocalInd;
                <!when use int as key, use key as index!>
                <if(dynamic || !IsKeyAsIndex.(keyType))>
                    <keyType> adjacency = adjacencies.get(i);
                    synchronized(keyIndMap){
                        if(keyIndMap.contains(adjacency))
                            adjacentLocalInd = keyIndMap.get(adjacency);
                        else{
                            <if(IsPairKey.(keyType))>
                            adjacentLocalInd = addEntry(adjacency.getV0(), adjacency.getV1(), IDENTITY_ELEMENT, IDENTITY_ELEMENT);
                            <else>
                            adjacentLocalInd = addEntry(adjacency, IDENTITY_ELEMENT, IDENTITY_ELEMENT);
                            <endif>
                        }
                    }
                <else>
                    adjacentLocalInd = adjacencies.get(i); //key for adjacent node
                <endif>
                <if(sync)>
                    if (iter % 2 == 0) {
                        <if(IsSum.(aggrType))>bufferDeltaList.get(adjacentLocalInd).addAndGet(newDelta);<endif>
                        <if(IsMax.(aggrType))>bufferDeltaList.get(adjacentLocalInd).accumulateAndGet(newDelta, Math::max);<endif>
                        <if(IsMin.(aggrType))>bufferDeltaList.get(adjacentLocalInd).accumulateAndGet(newDelta, Math::min);<endif>
                        <if(IsCount.(aggrType))>bufferDeltaList.get(adjacentLocalInd).addAndGet(1);<endif>
                    } else {
                        <if(IsSum.(aggrType))>deltaList.get(adjacentLocalInd).addAndGet(newDelta);<endif>
                        <if(IsMax.(aggrType))>deltaList.get(adjacentLocalInd).accumulateAndGet(newDelta, Math::max);<endif>
                        <if(IsMin.(aggrType))>deltaList.get(adjacentLocalInd).accumulateAndGet(newDelta, Math::min);<endif>
                        <if(IsCount.(aggrType))>deltaList.get(adjacentLocalInd).addAndGet(1);<endif>
                    }
                <else>
                    <if(IsSum.(aggrType))>deltaList.get(adjacentLocalInd).addAndGet(newDelta);<endif>
                    <if(IsMax.(aggrType))>deltaList.get(adjacentLocalInd).accumulateAndGet(newDelta, Math::max);<endif>
                    <if(IsMin.(aggrType))>deltaList.get(adjacentLocalInd).accumulateAndGet(newDelta, Math::min);<endif>
                    <if(IsCount.(aggrType))>deltaList.get(adjacentLocalInd).addAndGet(oldDelta);<endif>
                <endif>
            }
        <endif>
        return true;
    }

    <if(IsBoolean.(valueType))>
    private boolean eval(<deltaType> oldDelta) {
        return (<expr>);
    }
    <else>
    private <deltaType> eval(<deltaType> oldDelta <if(weightType)>,<weightType> weight<endif> <if(extraType)>, <extraType> extra<endif>) {
        return (<deltaType>)(<expr>);
    }
    <endif>

    private synchronized int addEntry(<if(IsPairKey.(keyType))>int col1OfKey, int col2OfKey<else><keyType> key<endif>, <valueType> value, <deltaType> delta){
        <if(IsPairKey.(keyType))>Pair key = new Pair(col1OfKey, col2OfKey);<endif>
        keyIndMap.put(key, size);
        indKeyMap.add(key);
        valueList.add(value);
        deltaList.add(new <TypeAtomic.(deltaType)>(delta));
        <if(sync)>bufferDeltaList.add(new <TypeAtomic.(deltaType)>(IDENTITY_ELEMENT));<endif>
        <if(IsBoolean.(valueType))>sentFlagList.add(false);<endif>
        return size++;
    }
    
    @Override
    public VisitorImpl getInitVisitor(){
        return new VisitorImpl(){
            @Override
            public boolean visit(<if(IsPairKey.(keyType))>int col1OfKey, int col2OfKey<else><keyType> key<endif>, <valueType> initDelta) {
                addEntry(<if(IsPairKey.(keyType))>col1OfKey, col2OfKey<else>key<endif>, initDelta);
            }
        };
    }

    @Override
    public VisitorImpl getEdgeVisitor(){
        return new VisitorImpl() {
            <PrimitiveList.(keyType)> dstList;
            @Override
            public boolean visit_0(<if(IsPairKey.(keyType))>int<else><keyType><endif> key) {
                dstList = srcDstListMap.get(key);
                if(dstList == null){
                    dstList = new <PrimitiveList.(keyType)>();
                    srcDstListMap.put(key, dstList);
                }
                return true;
            }

            @Override
            public boolean visit(<if(IsPairKey.(keyType))>int<else><keyType><endif> dst <if(weightType)>,<weightType> weight<endif>) {
                dstList.add(dst);
                <if(weightType)>dstList.add(weight);<endif>
                return true;
            }
        };
    }
    
    <if(extraType)>
    @Override
    public VisitorImpl getExtraVisitor(){
        return new VisitorImpl(){
            @Override
            public boolean visit(<keyType> key, <extraType> extra){
                keyExtraMap.put(key, extra)
            }
        }
    }
    <endif>
    
    @Override
    <if(IsBoolean.(valueType))>
    public double accumulateValue(){
        double sum = 0;
        for(int i=0;i\<size;i++)
            if(valueList.get(i)){
                sum++;
            }
        return sum;
    }
    <else>
    public double accumulateValue(){
        double sum = 0;

        for(int i=0;i\<size;i++){
            <valueType> value = valueList.get(i);
            if(value != IDENTITY_ELEMENT){
                sum+=value;
            }
        }
        return sum;
    }
    <endif>

    @Override
    public double getPriority(int localInd){
        <if(IsSum.(aggrType))>
        <PrimitiveList.(keyType)> adjacencies = adjacenciesList.get(localInd);
        //if (adjacencies == null)
            return deltaList.get(localInd).get();
        //return deltaList.get(localInd).get() / adjacencies.size();
        <elseif(IsMax.(aggrType))>
        double val = valueList.get(localInd);
        double delta = deltaList.get(localInd).get();
        return val - Math.max(val, delta);
        <elseif(IsMin.(aggrType))>
        double val = valueList.get(localInd);
        double delta = deltaList.get(localInd).get();
        return val - Math.min(val, delta);
        <elseif(IsCount.(aggrType))>
        return deltaList.get(localInd).get();
        <endif>
    }

    @Override
    public double accumulateDelta(){
        double sum = 0;

        for(int i=0;i\<size;i++){
            <deltaType> delta = deltaList.get(i).get();
            if(delta != IDENTITY_ELEMENT){
                sum+=delta;
            }
            <if(sync)>
            delta = bufferDeltaList.get(i).get();
            if(delta != IDENTITY_ELEMENT){
                sum+=delta;
            }
            <endif>

        }
        return sum;
    }

	@Override
	public void iterate(QueryVisitor queryVisitor){
	    Tuple tuple;
	    for (int i=0; i\<size; i++) {
            <if(dynamic || !IsKeyAsIndex.(keyType))>
                <if(IsPairKey.(keyType))>
                    Pair pair = indKeyMap.get(i);
                    tuple = new Tuple_Object_<valueType>_<deltaType>();
                    tuple.set<WrappedTypeForTupleMap.(keyType)>(0, pair.toString());
                    tuple.set<WrappedTypeForTupleMap.(valueType)>(1, valueList.get(i));
                    tuple.set<WrappedTypeForTupleMap.(deltaType)>(2, deltaList.get(i).get());
                    if(!queryVisitor.visit(tuple))
                        break;
                <elseif(IsBoolean.(valueType))>
                    if(valueList.get(i)){
                        tuple = new Tuple_<keyType>();
                        tuple.set<WrappedTypeForTupleMap.(keyType)>(0, indKeyMap.get(i));
                        if(!queryVisitor.visit(tuple))
                            break;
                    }
                <else>
                    tuple = new Tuple_<keyType>_<valueType>_<valueType>();
                    tuple.set<WrappedTypeForTupleMap.(keyType)>(0, indKeyMap.get(i));
                    tuple.set<WrappedTypeForTupleMap.(valueType)>(1, valueList.get(i));
                    tuple.set<WrappedTypeForTupleMap.(deltaType)>(2, deltaList.get(i).get());
                    if(!queryVisitor.visit(tuple))
                        break;
                <endif>
            <else>
                tuple = new Tuple_<keyType>_<valueType>_<valueType>();
                tuple.set<WrappedTypeForTupleMap.(keyType)>(0, i);
                tuple.set<WrappedTypeForTupleMap.(valueType)>(1, valueList.get(i));
                tuple.set<WrappedTypeForTupleMap.(deltaType)>(2, deltaList.get(i).get());
                if(!queryVisitor.visit(tuple))
                    break;
            <endif>
	    }
	    queryVisitor.finish();
	}

	@Override
	public synchronized int getSize(){
	    return size;
	}
}
>>