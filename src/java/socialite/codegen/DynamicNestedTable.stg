group dynamic-nested-table;
import "TableCommon.stg"

dynamicNestedTable(tableName, name, visitorClass, nestedTable, classes, methods, 
        size, id, 
        columns, nestedColumns, nestedNestedColumns, gbColumns, gbNestedColumns, gbAggrColumn,
        sortedCol, idxCols,
        concurrent=false, multiSet=false, isNested=false) ::= <<
<if(!isNested)>
package socialite.tables;

<importForTable()>
<endif>

// dynamicNestedTable
<if(!isNested)>public<endif> class <name> extends AbstractTableInst {
    private static final long serialVersionUID = 1;
    
    public static int tableid() { return <id>; }
    public static <name> create() { return new <name>(); }
    
    static int makePos(int nodePos, int offset) { return (nodePos \<\< 8) | offset; }
    static int getPos(int val) { return (val >\>> 8); }
    static int getOffset(int val) { return (val & 0xff); }
    
    static final class Node$Init extends Node {
        static final int INIT_CHUNK_SIZE=2;
        Node$Init() { super(INIT_CHUNK_SIZE); }

        int insert(<columns:{c|<c.type> a<i0>}; separator=", "><nestedColumns:{c|, <c.type> b<i0>}>) {
            if (len() == col0().length) {
                expand();
            }
            return super.insert(<columns:{c|a<i0>}; separator=", "><nestedColumns:{c|, b<i0>}>);
        }
        void expand() {
            int size = len()*3/2;
            if (size > CHUNK_SIZE) { size=CHUNK_SIZE; }
            <columns:{c|<c.type>[] _col<i0> = new <c.type>[size];<\n>}>
            <columns:{c|System.arraycopy(col<i0>, 0, _col<i0>, 0, len());<\n>}>
            <columns:{c|col<i0> = _col<i0>;<\n>}>            
            <nestedTable>[] _nested = new <nestedTable>[size];
            System.arraycopy(nested, 0, _nested, 0, len());
            nested = _nested;
        }
    } // Node$Init class
    static class Node {
        static final int CHUNK_SIZE=128;

        volatile <columns:{c|Object col<i0>;<\n>}>
        volatile <nestedTable>[] nested;
        volatile int len;

        Node() { this(CHUNK_SIZE); }
        Node(int capacity) {
            <columns:{c|col<i0> = <if(c.arrayType)>new <c.componentType>[capacity][];<else>new <c.type>[capacity];<endif><\n>}>
            nested = new <nestedTable>[capacity];
        }
        Node copyOfRange(int from, int to) {
            Node n = new Node();
            <columns:{c|System.arraycopy(col<i0>(), from, n.col<i0>(), 0, to-from);<\n>}>
            System.arraycopy(nested, 0, n.nested, 0, len());
            n.len = to-from;
            return n;
        }

        boolean isEmpty() { return len() == 0;}
        boolean isFull() { return len() == CHUNK_SIZE; }
        int len() {
            int l = len;
            if (l \< 0) { l = -l-1; }
            return l;
        }

        static long lenOffset;
        static {
            if (CHUNK_SIZE > 256) { throw new AssertionError("CHUNK_SIZE too big!"); }
            try {
                lenOffset = unsafe.objectFieldOffset(Node.class.getDeclaredField("len"));
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }

        void wlock() {
            do {
                int l = len;
                if (l >= 0 && unsafe.compareAndSwapInt(this, lenOffset, l, -l-1)) {
                    break;
                }
            } while (true);
        }
        void wunlock() {
            int l = len;
            unsafe.compareAndSwapInt(this, lenOffset, l, -l-1);
        }

        <columns:{c|<c.type>[] col<i0>() { return (<c.type>[])col<i0>; \}<\n>}>

        public String toString() {
            String s="{";
            for (int i=0; i\<len(); i++) {
                s+="(";
                <columns:{c|s+= col<i0>()[i]+" ";<\n>}>
                s+="("+nested[i]+")";
                s+="),";
            }
            s+="}";
            return s;
        }
    <if(sortedCol)>
        int binarySearch1(<sortedCol.type> val) {
            int pos = Arrays.binarySearch(col<sortedCol.relPos>(), 0, len, val);
            if (pos \< 0) { return pos; }
            while (pos > 0) {
                pos--;
                if (!(col<sortedCol.relPos>()[pos]<EqOpMap.(sortedCol.type)>(val))) {
                    return pos+1;
                }
            }
            return pos;
        }
        boolean contains_sorted(<columns:{c|<c.type> a<i0>}; separator=", "><nestedColumns:{c|, <c.type> b<i0>}>, boolean[] dontcare) {
            int pos = binarySearch1(a<sortedCol.relPos>);
            if (pos \< 0) { return false; }
            boolean[] dontcareNested = null;
            if (dontcare!=null) dontcareNested = Arrays.copyOfRange(dontcare, <length(columns)>, dontcare.length);
            for (int i=pos; i\<len(); i++) {
                if (!(col<sortedCol.relPos>()[i]<EqOpMap.(sortedCol.type)>(a<sortedCol.relPos>))) { return false; }
                if (contains_at(<columns:{c|a<i0>}; separator=", ">,i,dontcare) &&
                    nested[i].contains(<nestedColumns:{c|b<i0>};separator=",">, dontcareNested)) { return true; }
            }
            return false;
        }
    <endif>
        boolean contains(<columns:{c|<c.type> a<i0>};separator=", "><nestedColumns:{c|, <c.type> b<i0>}>, boolean[] dontcare) {
            <withConsistentLen(ret="ret",
                               code={boolean ret=_contains(<columns:{c|a<i0>};separator=", "><nestedColumns:{c|, b<i0>}>, dontcare);})>
        }
        boolean _contains(<columns:{c|<c.type> a<i0>};separator=", "><nestedColumns:{c|, <c.type> b<i0>}>, boolean[] dontcare) {
        <if(sortedCol)>
            if (dontcare==null || !dontcare[<sortedCol.relPos>]) {
                return contains_sorted(<columns:{c|a<i0>}; separator=", "><nestedColumns:{c|,b<i0>}>,dontcare);
            }
        <endif>
            boolean[] dontcareNested = null;
            if (dontcare!=null) { dontcareNested = Arrays.copyOfRange(dontcare, <length(columns)>, dontcare.length); }
            for (int i=0; i\<len(); i++) {
                if (true<columns:{c|&& (dontcare[<i0>]||col<i0>()[i]<EqOpMap.(c.type)>(a<i0>))}>) {
                    return nested[i].contains(<nestedColumns:{c|b<i0>};separator=",">, dontcareNested);
                }
            }
            return false;
        }
        boolean contains(<columns:{c|<c.type> a<i0>};separator=", "><nestedColumns:{c|, <c.type> b<i0>}>) {
            <withConsistentLen(ret="ret",
                               code={boolean ret=_contains(<columns:{c|a<i0>};separator=", "><nestedColumns:{c|, b<i0>}>);})>
        }
        boolean _contains(<columns:{c|<c.type> a<i0>};separator=", "><nestedColumns:{c|, <c.type> b<i0>}>) {
        <if(sortedCol)>
            if (true) {return contains_sorted(<columns:{c|a<i0>}; separator=", "><nestedColumns:{c|,b<i0>}>,null);}
        <endif>
            for (int i=0; i\<len(); i++) {
                if (true<columns:{c|&& col<i0>()[i]<EqOpMap.(c.type)>(a<i0>)}>) {
                    return nested[i].contains(<nestedColumns:{c|b<i0>};separator=",">);
                }
            }
            return false;
        }
        boolean contains_at(<columns:{c|<c.type> a<i0>, }>int at, boolean[] dontcare) {
            <withConsistentLen(ret="ret",
                               code={boolean ret=_contains_at(<columns:{c|a<i0>, }>at, dontcare);})>
        }
        boolean _contains_at(<columns:{c|<c.type> a<i0>, }>int at, boolean[] dontcare) {
            if (dontcare==null) {return contains_at(<columns:{c|a<i0>}; separator=", ">,at);}
            return true<columns:{c|&& (dontcare[<i0>]||a<i0><EqOpMap.(c.type)>(col<i0>()[at]))}>;
        }
        boolean contains_at(<columns:{c|<c.type> a<i0>, }>int at) {
             <withConsistentLen(ret="ret",
                                code={boolean ret=_contains_at(<columns:{c|a<i0>, }>at);})>
        }
        boolean _contains_at(<columns:{c|<c.type> a<i0>, }>int at) {
            return true<columns:{c|&& a<i0><EqOpMap.(c.type)>(col<i0>()[at])}>;
        }
        boolean contains_at(<columns:{c|<c.type> a<i0>, }><nestedColumns:{c|<c.type> b<i0>, }>int at, boolean[] dontcare) {
              <withConsistentLen(ret="ret",
                                 code={boolean ret=_contains_at(<columns:{c|a<i0>, }><nestedColumns:{c|b<i0>, }>at, dontcare);})>
        }
        boolean _contains_at(<columns:{c|<c.type> a<i0>, }><nestedColumns:{c|<c.type> b<i0>, }>int at, boolean[] dontcare) {
            if (dontcare==null) {return contains_at(<columns:{c|a<i0>}; separator=", "><nestedColumns:{c|,b<i0>}>,at);}
            return true<columns:{c|&& (dontcare[<i0>]||a<i0><EqOpMap.(c.type)>(col<i0>()[at]))}> &&
                        nested[at].contains(<nestedColumns:{c|b<i0>};separator=",">,
                                    Arrays.copyOfRange(dontcare, <length(columns)>, dontcare.length));
        }
        boolean contains_at(<columns:{c|<c.type> a<i0>, }><nestedColumns:{c|<c.type> b<i0>, }>int at) {
            <withConsistentLen(ret="ret",
                               code={boolean ret=_contains_at(<columns:{c|a<i0>, }><nestedColumns:{c|b<i0>, }>at);})>
        }
        boolean _contains_at(<columns:{c|<c.type> a<i0>, }><nestedColumns:{c|<c.type> b<i0>, }>int at) {
            return true<columns:{c|&& a<i0><EqOpMap.(c.type)>(col<i0>()[at])}> &&
                        nested[at].contains(<nestedColumns:{c|b<i0>};separator=",">);
        }
        int inc_len() {
            if (len \< 0) { return -(len--)-1; }
            else { return len++; }
        }
    <if(sortedCol)>
        int insert_sorted(<columns:{c|<c.type> a<i0>};separator=", "><nestedColumns:{c|, <c.type> b<i0>}>) {
            int pos = -1;
            if (len() == 0) { pos = 0; }
            else { pos = Arrays.binarySearch(col<sortedCol.relPos>(), 0, len(), a<sortedCol.relPos>); }
            if (pos \< 0) { pos = -pos-1; }
            if (pos != len()) {
                <columns:{c|System.arraycopy(col<i0>(), pos, col<i0>(), pos+1, len-pos);<\n>}>
                System.arraycopy(nested, pos, nested, pos+1, len-pos);
            }
            <columns:{c|col<i0>()[pos] = a<i0>;<\n>}>
            <nestedTable> nested = nested[pos];
            if (nested == null) { nested = nested[pos] = new <nestedTable>(); }
            nested.insert(<nestedColumns:{c|b<i0>};separator=",">);
            return inc_len();
        }
        boolean insert_with_prefix(<columns:{c|<c.type> a<i0>};separator=", "><nestedColumns:{c|, <c.type> b<i0>}>) {
            int pos = binarySearch1(a<sortedCol.relPos>);
            assert pos>=0;
            for (int i=pos; i\<len(); i++) {
                if (col<sortedCol.relPos>()[i]<EqOpMap.(c.type)>(a<sortedCol.relPos>)) { return false; }
                if (contains_at(<columns:{c|a<i0>}; separator=", ">,i)) {
                    nested[i].insert(<nestedColumns:{c|b<i0>};separator=",">);
                    return true;
                }
            }
            return false;
        }
        boolean iterate_sorted_by_<sortedCol.absPos>(<sortedCol.type> a, <visitorClass> v) {
            <withConsistentLenCopy(
              init={int _len = len();
                    <columns:{c|<c.type>[] _col<i0> = col<i0>();}>
                    <nestedTable> _nested = nested;},
              code={_len = len();<\n>
                    <columns:{c|_col<i0> = <if(c.arrayType)>new <c.componentType>[_len][];<else>new <c.type>[_len];<endif><\n>}>
                    <columns:{c|System.arraycopy(col<i0>, 0, _col<i0>, 0, _len);<\n>}>
                    System.arraycopy(nested, 0, _nested, 0, _len);})>

            int pos = Arrays.binarySearch(_col<sortedCol.relPos>, 0, _len, a);
            if (pos \< 0) { return false; }

            for (int i=pos; i\<_len; i++) {
                if (!(_col<sortedCol.relPos>[i]<EqOpMap.(sortedCol.type)>(a))) {
                    return false;
                }
                boolean cont=v.visit<columns:{c|_<c.absPos>}>(<columns:{c|col<i0>()[i]}; separator=",">);
                if (cont) { _nested[i].iterate(v); }
            }
            return true;
        }
    <endif>
        int insert(<columns:{c|<c.type> a<i0>};separator=", "><nestedColumns:{c|, <c.type> b<i0>}>) {
            <if(sortedCol)>if(true) {return insert_sorted(<columns:{c|a<i0>};separator=", "><nestedColumns:{c|,b<i0>}>);}<endif>
            <columns:{c|col<i0>()[len()] = a<i0>;<\n>}>
            if (nested[len()] == null) { nested[len()] = new <nestedTable>(); }
            nested[len()].insert(<nestedColumns:{c|b<i0>};separator=",">);
            return inc_len();
        }
        boolean iterate(<visitorClass> v) {
            <withConsistentLenCopy(
              init={int _len = len();
                    <columns:{c|<c.type>[] _col<i0> = col<i0>();}>
                    <nestedTable>[] _nested = nested;},
              code={_len = len();<\n>
                    <columns:{c|_col<i0> = <if(c.arrayType)>new <c.componentType>[_len][];<else>new <c.type>[_len];<endif><\n>}>
                    <columns:{c|System.arraycopy(col<i0>, 0, _col<i0>, 0, _len);<\n>}>
                    System.arraycopy(nested, 0, _nested, 0, _len);})>

            for (int i=0; i\<_len; i++) {
                boolean cont=v.visit<columns:{c|_<c.absPos>}>(<columns:{c|_col<i0>[i]}; separator=",">);
                if (cont) _nested[i].iterate(v);
            }
            return true;
        }
        boolean iterate_at(<visitorClass> v, int pos) {
             <withConsistentLenCopy(
               init={int _len = len();
                     <columns:{c|<c.type> _col<i0> = col<i0>()[pos];<\n>}>
                     <nestedTable> _nested = nested[pos];},
               code={_len = len();<\n>
                     <columns:{c|_col<i0> = col<i0>()[pos];}>
                     _nested = nested[pos];})>

            boolean cont=v.visit<columns:{c|_<c.absPos>}>(<columns:{c|_col<i0>}; separator=",">);
            if (cont) { _nested.iterate(v); }
            return true;
        }
        <nestedColumns:{c|<if(c.indexed)>
            boolean iterate_by_<c.absPos>_at(<c.type> a, <visitorClass> v, int at) {
                <withConsistentLenCopy(
                  init={int _len = len();
                        <columns:{c|<c.type> _col<i0> = col<i0>()[pos];<\n>}>
                        <nestedTable> _nested = nested[pos];},
                  code={_len = len();<\n>
                        <columns:{c|_col<i0> = col<i0>()[pos];}>
                        _nested = nested[pos];})>
                boolean cont=v.visit<columns:{c2|_<c2.absPos>}>(<columns:{c2|_col<i0>}; separator=",">);
                if (cont) { _nested.iterate_by_<c.absPos>(a, v); \}
                return true;
            \}<endif>
            <if(c.sorted)>
            boolean iterate_part_from_<c.absPos>(<c.type> from, boolean inclusive, <visitorClass> v) {
                <withConsistentLenCopy(
                  init={int _len = len();
                        <columns:{c|<c.type> _col<i0> = col<i0>()[pos];<\n>}>
                        <nestedTable> _nested = nested[pos];},
                  code={_len = len();<\n>
                        <columns:{c|_col<i0> = col<i0>()[pos];}>
                        _nested = nested[pos];})>
                for (int i=0; i\<_len; i++) {
                    boolean cont=v.visit<columns:{c|_<c.absPos>}>(<columns:{c|_col<i0>}; separator=",">);
                    if (cont) { _nested.iterate_part_from_<c.absPos>(from, inclusive, v); \}
                \}
                return true;
            \}
            boolean iterate_part_to_<c.absPos>(<c.type> to, boolean inclusive, <visitorClass> v) {
                <withConsistentLenCopy(
                  init={int _len = len();
                        <columns:{c|<c.type> _col<i0> = col<i0>()[pos];<\n>}>
                        <nestedTable> _nested = nested[pos];},
                  code={_len = len();<\n>
                        <columns:{c|_col<i0> = col<i0>()[pos];}>
                        _nested = nested[pos];})>
                for (int i=0; i\<_len; i++) {
                    boolean cont=v.visit<columns:{c|_<c.absPos>}>(<columns:{c|_col<i0>}; separator=",">);
                    if (cont) { _nested.iterate_part_to_<c.absPos>(to, inclusive, v); \}
                \}
                return true;
            \}
            boolean iterate_part_from_<c.absPos>_at(<c.type> from, boolean inclusive, <visitorClass> v, int at) {
                <withConsistentLenCopy(
                  init={int _len = len();
                        <columns:{c|<c.type> _col<i0> = col<i0>()[pos];<\n>}>
                        <nestedTable> _nested = nested[pos];},
                  code={_len = len();<\n>
                        <columns:{c|_col<i0> = col<i0>()[pos];}>
                        _nested = nested[pos];})>
                boolean cont=v.visit<columns:{c|_<c.absPos>}>
                                    (<columns:{c|col<i0>()[at]}; separator=",">);
                if (cont) {nested[at].iterate_part_from_<c.absPos>(from, inclusive, v);\}
                return true;
            \}
            boolean iterate_part_to_<c.absPos>_at(<c.type> from, boolean inclusive, <visitorClass> v, int at) {
                boolean cont=v.visit<columns:{c|_<c.absPos>}>
                                    (<columns:{c|col<i0>()[at]}; separator=",">);
                if (cont) {nested[at].iterate_part_to_<c.absPos>(from, inclusive, v);\}
                return true;
            \}
            <endif>
        }>
    } // end of Node class

    ConcurrentReadArrayList\<Node> nodeList;
<if(first(idxCols))>
    <if(gbColumns && !rest(gbColumns) && first(gbColumns).indexed)>
        SPosIndexPacked index<first(idxCols).relPos> = new SPosIndexPacked();
    <else>
        SPosIndex index<first(idxCols).relPos> = new SPosIndex();
    <endif>
<endif>
    <rest(idxCols):{ic|SPosIndex index<ic.relPos> = new SPosIndex();<\n>}>
<if(gbColumns)>
    <if(!rest(gbColumns) && first(gbColumns).indexed)>
        SPosIndexPacked groupbyMap = index<first(gbColumns).relPos>;
    <else>
        SPosIndexPacked groupbyMap = new SPosIndexPacked();
    <endif>
<endif>

    public <name>() {
        nodeList = new ConcurrentReadArrayList\<Node>(2);
    }

    /** synchronization fields and methods */
    static volatile boolean readConsistencyCheckRequired = false;
    AtomicInteger lockCount = new AtomicInteger(0);
    ReentrantLock lock = new ReentrantLock();
    public void wlock(<first(columns).type> unused) { lockCount.incrementAndGet(); }
    public void wunlock(<first(columns).type> unused) { lockCount.decrementAndGet(); }
    boolean requireLock() { return lockCount.get() > 0; }
    void lock() { if (requireLock()) { lock.lock(); } }
    void unlock() { if (requireLock()) { lock.unlock(); } }
    void lock(Node n) { if (requireLock()) { n.wlock(); } }
    void unlock(Node n) { if (requireLock()) { n.wunlock(); } }

    private static final sun.misc.Unsafe unsafe;
    static {
        try { unsafe = getUnsafe(); }
        catch (Exception e) { throw new Error(e); }
    }
    public static Unsafe getUnsafe() {
        try {
            Field singleoneInstanceField = Unsafe.class.getDeclaredField("theUnsafe");
            singleoneInstanceField.setAccessible(true);
            return (Unsafe) singleoneInstanceField.get(null);
        } catch (Exception e) {
            throw new RuntimeException("Could not find 'theUnsafe' field in the " + Unsafe.class);
        }
    }

    public int id() { return <id>; }
    public int size() { assert false; return -1; }
    public String name() { return "<tableName>"; }

    public boolean isEmpty() { return nodeList.size() == 0; }
    public String toString() {
        String str="Table <tableName>(id=<id>):";
        return str + nodeList.getQuick(0).toString();
    }
    public void clearQuick() { clear(); }
    public void clear() {
        nodeList.clear();
        <idxCols:{ic|index<ic.relPos>.clear();<\n>}>
        <if(gbColumns)>groupbyMap.clear();<endif>
    }

    public boolean contains(<columns:{c|final <c.type> a<i0>};separator=", "><nestedColumns:{c|, final <c.type> b<i0>}>) {
    <if(sortedCol)>if (true) {return contains_sorted(<columns:{c|a<i0>};separator=","><nestedColumns:{c|,b<i0>}>,null);}<endif>
    <if(idxCols)>
        ConcurrentReadIntArrayList indices = index<first(idxCols).relPos>.get(a<first(idxCols).relPos>);
        if (indices == null) { return false; }
        for (int i=0; i\<indices.size(); i++) {
            int val = indices.getQuick(i);
            int pos = getPos(val);
            int offset = getOffset(val);
            Node n = nodeList.getQuick(pos);
            if (n.contains_at(<columns:{c|a<i0>};separator=", "><nestedColumns:{c|, b<i0>}>, offset)) {
                return true;
            }
        }
        return false;
    <else>
        for (int i=0; i\<nodeList.size(); i++) {
            Node n = nodeList.getQuick(i);
            if (n.contains(<columns:{c|a<i0>};separator=", "><nestedColumns:{c|, b<i0>}>)) {
                return true;
            }
        }
        return false;
    <endif>
    }

    public boolean contains(<columns:{c|final <c.type> a<i0>};separator=", "><nestedColumns:{c|, final <c.type> b<i0>}>, final boolean[] dontcare) {
    <if(sortedCol)> if(dontcare==null || !dontcare[<sortedCol.relPos>]) {return contains_sorted(<columns:{c|a<i0>};separator=","><nestedColumns:{c|, b<i0>}>, dontcare);} <endif>
        if (dontcare==null) {return contains(<columns:{c|a<i0>};separator=", "><nestedColumns:{c|, b<i0>}>);}
    <if(idxCols)>
        if (!dontcare[<first(idxCols).relPos>]) {
            ConcurrentReadIntArrayList indices = index<first(idxCols).relPos>.get(a<first(idxCols).relPos>);
            if (indices == null) { return false; }
            for (int i=0; i\<indices.size(); i++) {
                int val = indices.getQuick(i);
                int pos = getPos(val);
                int offset = getOffset(val);
                Node n = nodeList.getQuick(pos);
                if (n.contains_at(<columns:{c|a<i0>};separator=", "><nestedColumns:{c|, b<i0>}>, offset, dontcare)) {
                    return true;
                }
            }
            return false;
        }
    <endif>
        for (int i=0; i\<nodeList.size(); i++) {
            Node n = nodeList.getQuick(i);
            if (n.contains(<columns:{c|a<i0>};separator=", "><nestedColumns:{c|, b<i0>}>, dontcare)) {
                return true;
            }
        }
        return false;
    }

    void addToIndex(<idxCols:{ic|<ic.type> a<ic.relPos> ,}>int pos) {
        <idxCols:{ic|index<ic.relPos>.add(a<ic.relPos>, pos);<\n>}>
    }
    void addToGroupbyMap(<gbColumns:{g|<g.type> a<g.relPos>,}>int pos) {
    <if(gbColumns)>
        <if(rest(gbColumns))>
            Tuple<gbColumns:{g|_<TupleMap.(g.type)>}> groupbyTup = new Tuple<gbColumns:{g|_<TupleMap.(g.type)>}>();
            <gbColumns:{g|groupbyTup._<i0> = a<i0>;}; separator="\n">
             groupbyMap.add(groupbyTup, pos);
        <elseif(first(gbColumns).indexed)>
             assert groupbyMap == index<first(gbColumns).relPos>;
        <else>
            groupbyMap.add(a0, pos);
        <endif>
    <endif>
    }
<if(sortedCol)>
    int binarySearch(<sortedCol.type> v, ConcurrentReadArrayList\<Node> _nodeList) {
        if (_nodeList.size()==0) {return -1;}
        int lo=0, hi=_nodeList.size()-1;
        <sortedCol.type> midVal1, midVal2;
        while (lo \<= hi) {
            int mid = (lo+hi)/2;
            Node n = _nodeList.getQuick(mid);
            int _len = n.len();
            midVal1 = n.col<sortedCol.relPos>()[0];
            midVal2 = n.col<sortedCol.relPos>()[_len-1];
        <if(sortedCol.primitive)>
            if (midVal2 \< v) {lo = mid+1;}
            else if (midVal1 > v) {hi = mid-1;}
            else {return mid;}
        <else>
            if (midVal2.compareTo(v) \< 0) {lo = mid+1;}
            else if (midVal1.compareTo(v) > 0) {hi = mid-1;}
            else {return mid;}
        <endif>
        }
        if (lo == _nodeList.size()) {
            if (!_nodeList.get(lo-1).isFull()) { lo--; }
        }
        return -(lo+1);
    }
    int binarySearch1(<sortedCol.type> v, ConcurrentReadArrayList\<Node> _nodeList) {
        int pos = binarySearch(v);
        if (pos \< 0) return pos;
        while (pos > 0) {
            pos--;
            Node n = _nodeList.getQuick(pos);
            int _len = n.len();
            if (!(n.col<sortedCol.relPos>()[_len-1]<EqOpMap.(sortedCol.type)>(v))) {return pos+1;}
        }
        return pos;
    }
    int binarySearch2(<sortedCol.type> v, ConcurrentReadArrayList\<Node> _nodeList) {
        int pos = binarySearch(v);
        if (pos \< 0) return pos;
        while (pos \< _nodeList.size()-1) {
            pos++;
            Node n = _nodeList.getQuick(pos);
            if (!(n.col<sortedCol.relPos>()[0]<EqOpMap.(sortedCol.type)>(v))) {return pos-1;}
        }
        return pos;
    }
    boolean contains_sorted(<columns:{c|<c.type> a<i0>};separator=", "><nestedColumns:{c|,<c.type> b<i0>}>,boolean[] dontcare) {
        <withConsistentNodeList(nodeList="myNodeList",
            code={int pos = binarySearch1(a<sortedCol.relPos>, myNodeList);
                  if (pos \< 0) {return false;\}
                  for (int i=pos; i\<myNodeList.size(); i++) {
                  <if(sortedCol.primitive)>
                      if (myNodeList.getQuick(i).col<sortedCol.relPos>()[0] > a<sortedCol.relPos>) {return false;\}
                  <else>
                      if (myNodeList.getQuick(i).col<sortedCol.relPos>()[0].compareTo(a<sortedCol.relPos>) > 0) {return false;\}
                  <endif>
                      if (nodeList.getQuick(i).contains(<columns:{c|a<i0>,}><nestedColumns:{c| b<i0>,}> dontcare)) {
                          return true;
                      \}
                  \}
                  return false;})>
    }
    boolean insert_sorted(<columns:{c|final <c.type> a<i0>};separator=", "><nestedColumns:{c|, final <c.type> b<i0>}>) {
        lock();
    <if(!isNested && !multiSet)>
        if (contains(<columns:{c|a<i0>};separator=","><nestedColumns:{c|, b<i0>}>)) {
            unlock();
            return false;
        }
    <endif>
        int pos = binarySearch1(a<sortedCol.relPos>, nodeList);
        boolean found = pos >= 0;
        if (pos \< 0) { pos = -pos-1; }
        if (found) {
            for (int i=pos; i \< nodeList.size(); i++) {
                Node n = nodeList.getQuick(pos);
            <if(sortedCol.primitive)>
                if (n.col<sortedCol.relPos>()[0] > a<sortedCol.relPos>) {break;}
            <else>
                if (n.col<sortedCol.relPos>()[0].compareTo(a<sortedCol.relPos>) > 0) {break;}
            <endif>
                if (n.insert_with_prefix(<columns:{c|a<i0>};separator=","><nestedColumns:{c|,b<i0>}>)) {
                    return true;
                }
            }
        }

        if (nodeList.size() == 0) {
            Node n = new Node$Init();
            n.insert(<columns:{c|a<i0>};separator=", "><nestedColumns:{c|,b<i0>}>);
            nodeList.add(n);
            unlock();
            return true;
        } else {
            if (pos >= nodeList.size()) { pos = nodeList.size()-1; }
            Node n = nodeList.getQuick(pos);
            lock(n);
            if (n.isFull()) {
                Node n1 = n.copyOfRange(0, n.len()/2);
                Node n2 = n.copyOfRange(n.len()/2, n.len());
            <if(sortedCol.primitive)>
                boolean smaller = a<sortedCol.relPos> \< n2.col<sortedCol.relPos>()[0];
            <else>
                boolean smaller = a<sortedCol.relPos>.compareTo(n2.col<sortedCol.relPos>()[0]) \< 0;
            <endif>
                if (smaller) {
                    n1.insert(<columns:{c|a<i0>};separator=", "><nestedColumns:{c|,b<i0>}>);
                } else {
                    n2.insert(<columns:{c|a<i0>};separator=", "><nestedColumns:{c|,b<i0>}>);
                }
                nodeList.replaceWith(pos, n1, n2);
                unlock();
                unlock(n);
            } else {
                unlock();
                n.insert(<columns:{c|a<i0>};separator=", "><nestedColumns:{c|,b<i0>}>);
                unlock(n);
            }
        }
        return true;
    }
<endif> <! if(sortedCol) !>
    boolean insert_with_prefix(<columns:{c|final <c.type> a<i0>};separator=", "><nestedColumns:{c|, final <c.type> b<i0>}>) {
    <if(idxCols)>
        ConcurrentReadIntArrayList indices = index<first(idxCols).relPos>.get(a<first(idxCols).relPos>);
        if (indices == null) { return false; }
        for (int i=0; i\<indices.size(); i++) {
            int val = indices.getQuick(i);
            int pos = getPos(val);
            int offset = getOffset(val);
            Node n = nodeList.getQuick(pos);
            if (true<columns:{c|&&(n.col<i0>()[offset]<EqOpMap.(c.type)>(a<i0>))}>) {
                lock(n);
                n.nested[offset].insert(<nestedColumns:{c|b<i0>};separator=",">);
                unlock(n);
                return true;
            }
        }
    <else>
        for (int j=0; j\<nodeList.size(); j++) {
            Node n = nodeList.getQuick(j);
            for (int i=0; i\<n.len(); i++) {
                if (true<columns:{c|&&(n.col<i0>()[i]<EqOpMap.(c.type)>(a<i0>))}>) {
                    lock(n);
                    n.nested[i].insert(<nestedColumns:{c|b<i0>};separator=",">);
                    unlock(n);
                    return true;
                }
            }
        }
        return false;
    <endif>
    }
    public boolean insert(<columns:{c|final <c.type> a<i0>};separator=", "><nestedColumns:{c|, final <c.type> b<i0>}>) {
    <if(sortedCol)> if (true) { return insert_sorted(<columns:{c|a<i0>};separator=", "><nestedColumns:{c|,b<i0>}>); } <endif>
        lock();
    <if(!isNested && !multiSet)>
        if (contains(<columns:{c|a<i0>};separator=","><nestedColumns:{c|,b<i0>}>)) {
            unlock();
            return false;
        }
    <endif>
        if (!isEmpty()) {
            boolean inserted = insert_with_prefix(<columns:{c|a<i0>};separator=", "><nestedColumns:{c|,b<i0>}>);
            if (inserted) {
                unlock();
                return true;
            }
        }
        int offset;
        if (nodeList.size() == 0) {
            Node n = new Node$Init();
            offset = n.insert(<columns:{c|a<i0>};separator=", "><nestedColumns:{c|, b<i0>}>);
            nodeList.add(n);
        } else {
            Node last = nodeList.getQuick(nodeList.size()-1);
            lock(last);
            if (last.isFull()) {
                unlock(last);
                last = new Node();
                offset = last.insert(<columns:{c|a<i0>};separator=", "><nestedColumns:{c|, b<i0>}>);
                nodeList.add(last);
            } else {
                offset = last.insert(<columns:{c|a<i0>};separator=", "><nestedColumns:{c|, b<i0>}>);
                unlock(last);
            }
        }
    <if(isNested || multiSet)>unlock(); <endif>
        int nodePos = nodeList.size()-1;
        int pos = makePos(nodePos, offset);
        addToIndex(<idxCols:{ic|a<ic.relPos> ,}>pos);
        addToGroupbyMap(<gbColumns:{g|a<g.relPos>, }>pos);
    <if(!isNested && !multiSet)>unlock(); <endif>
        return true;
    }

<if(gbColumns)> // if (gbColumns) [
    <groupbyDynNested()>
<endif> // ] if (gbColumns)

    public void iterate(<visitorClass> v) {
    <withConsistentNodeList(nodeList="myNodeList",
        code={for (int i=0; i\<myNodeList.size(); i++) {
                  Node n = myNodeList.getQuick(i);
                  boolean cont = n.iterate(v);
                  if (!cont) { return; \}
             \}})>
    }

<idxCols:{c|
    public void iterate_by_<c.absPos>(<c.type> a, final <visitorClass> v) {
        ConcurrentReadIntArrayList indices = index<c.relPos>.get(a);
        if (indices == null) { return; \}
        for (int i=0; i\<indices.size(); i++) {
            int val = indices.getQuick(i);
            int pos = getPos(val);
            int offset = getOffset(val);
            Node n = nodeList.getQuick(pos);
            n.iterate_at(v, offset);
        \}
    \}
    <nestedColumns:{nc|<if(nc.indexed)>
        public void iterate_by_<c.absPos>_<nc.absPos>(<c.type> a, final <nc.type> b, final <visitorClass> v) {
            ConcurrentReadIntArrayList indices = index<c.relPos>.get(a);
            if (indices == null) { return; \}
            for (int i=0; i\<indices.size(); i++) {
                int val = indices.getQuick(i);
                int pos = getPos(val);
                int offset = getOffset(val);
                Node n = nodeList.getQuick(pos);
                n.iterate_by_<nc.absPos>_at(b, v, offset);
            \}
        \}
        <endif>
        <if(nc.sorted)>
        public void iterate_part_from_<nc.absPos>_by_<c.absPos>(<c.type> a, final <nc.type> from, final boolean inclusive, final <visitorClass> v) {
            ConcurrentReadIntArrayList indices = index<c.relPos>.get(a);
            if (indices == null) { return; \}
            for (int i=0; i\<indices.size(); i++) {
                int val = indices.getQuick(i);
                int pos = getPos(val);
                int offset = getOffset(val);
                Node n = nodeList.getQuick(pos);
                n.iterate_part_from_<nc.absPos>_at(from, inclusive, v, offset);
            \}
        \}
        public void iterate_part_to_<nc.absPos>_by_<c.absPos>(<c.type> a, final <nc.type> to, final boolean inclusive, final <visitorClass> v) {
            ConcurrentReadIntArrayList indices = index<c.relPos>.get(a);
            if (indices == null) { return; \}
            for (int i=0; i\<indices.size(); i++) {
                int val = indices.getQuick(i);
                int pos = getPos(val);
                int offset = getOffset(val);
                Node n = nodeList.getQuick(pos);
                n.iterate_part_to_<nc.absPos>_at(to, inclusive, v, offset);
            \}
        \}
        <endif>
    }>
}>
<if(sortedCol)>
    public void iterate_by_<sortedCol.absPos>(<sortedCol.type> a, final <visitorClass> v) {
        <withConsistentNodeList(nodeList="myNodeList",
            code={int nodePos = binarySearch1(a, myNodeList);
                  if (nodePos \< 0) { nodePos = -nodePos-1; \}
                  for (int i=nodePos; i\<myNodeList.size(); i++) {
                      Node n = myNodeList.getQuick(i);
                      boolean cont = n.iterate_sorted_by_<sortedCol.absPos>(a, v);
                      if (!cont) { break; \}
                  \}
                  return;})>
    }
    public void iterate_part_from_<sortedCol.absPos>(<sortedCol.type> from, boolean inclusive, final <visitorClass> v) {
        <withConsistentNodeList(nodeList="myNodeList",
            code={int nodePos = binarySearch1(from, myNodeList);
                  if (nodePos \< 0) { nodePos = -nodePos-1; \}
                  for (int i=nodePos; i\<myNodeList.size(); i++) {
                      Node n = myNodeList.getQuick(i);
                      n.iterate(v);
                  \}})>
    }
    public void iterate_part_to_<sortedCol.absPos>(<sortedCol.type> to, boolean inclusive, final <visitorClass> v) {
        <withConsistentNodeList(nodeList="myNodeList",
            code={int nodePos = binarySearch2(to, myNodeList);
                  if (nodePos \< 0) { nodePos = -nodePos-1; \}
                  for (int i=0; i\<=nodePos; i++) {
                      Node n = myNodeList.getQuick(i);
                      n.iterate(v);
                  \}})>
    }
<endif> <! if(sortedCol) !>
<nestedColumns:{c|<if(c.sorted)>
    public void iterate_part_from_<c.absPos>(<c.type> from, boolean inclusive, <visitorClass> v) {
        <withConsistentNodeList(nodeList="myNodeList",
            code={for (int i=0; i\<myNodeList.size(); i++) {
                      Node n = myNodeList.getQuick(i);
                      n.iterate_part_from_<c.absPos>(from, inclusive, v);
                  \}})>
    \}
    public void iterate_part_to_<c.absPos>(<c.type> to, boolean inclusive, <visitorClass> v) {
        <withConsistentNodeList(nodeList="myNodeList",
            code={for (int i=0; i\<myNodeList.size(); i++) {
                      Node n = nodeList.getQuick(i);
                      n.iterate_part_to_<c.absPos>(to, inclusive, v);
                 \}})>
   \}
<endif>}>

    <methods;separator="\n">
}
<classes; separator="\n">
>>

groupbyGet() ::= <<
<if(rest(gbColumns))>
    Tuple<gbColumns:{g|_<TupleMap.(g.type)>}> groupbyTup = new Tuple<gbColumns:{g|_<TupleMap.(g.type)>}>();
    <gbColumns:{g|groupbyTup._<i0> = a<i0>;}; separator="\n">
    int pos = groupbyMap.get1(groupbyTup);
<else>
    int pos = groupbyMap.get1(a0);
<endif>
>>
groupbyGetRetry() ::= <<
<if(rest(gbColumns))>
    pos = groupbyMap.get1(groupbyTup);
<else>
    pos = groupbyMap.get1(a0);
<endif>
>>
getNodeAndOffset() ::= <<
    int nodePos = getPos(pos);
    Node n = nodeList.getQuick(nodePos);
    int offset = getOffset(pos);
>>

groupbyDynNested() ::= <<
<if(nestedNestedColumns)>
    static long shiftGroupby(long pos) { return pos \<\< (64-21); }
    static long composeGroupby(int pos, long offset) { return shiftGroupby(pos)|offset; }
    static int getGroupbyPos(long pos) { return (int)(pos >\>> (64-21)); }
    static long getGroupbyOffset(long pos) { return pos & 0x000007ffffffffffL; }
<else>
    static long shiftGroupby(long pos) { return pos \<\< 21; }
    static long composeGroupby(int pos, long offset) { return shiftGroupby(pos)|offset; }
    static int getGroupbyPos(long pos) { return (int)(pos >\>> 21); }
    static long getGroupbyOffset(long pos) { return pos & 0x00000000001fffffL; }
<endif>

<if(gbNestedColumns)> // if(gbNestedColumns) [
    public long groupby_getpos(<gbColumns:{c|<c.type> a<i0>};separator=", ">
                               <gbNestedColumns:{c|, <c.type> b<i0>}>) {
        lock();
        <groupbyGet()>
        if (pos \< 0) { return -1; }
        <getNodeAndOffset()>
        long gb_offset = n.nested[offset].groupby_getpos(<gbNestedColumns:{c|b<i0>}; separator=", ">);
        if (gb_offset \< 0) { return -1; }
        unlock();
        return composeGroupby(pos, gb_offset);
    }
    public <gbAggrColumn.type> groupby_groupby(long _pos) {
        int pos = getGroupbyPos(_pos);
        long gb_offset = getGroupbyOffset(_pos);
        <getNodeAndOffset()>
        lock(n);
        return n.nested[offset].groupby_groupby(gb_offset);
    }
    public boolean groupby_insert(<columns:{c|<c.type> a<i0>};separator=","><nestedColumns:{c|,<c.type> b<i0>}>) {
        insert(<columns:{c|a<i0>};separator=","><nestedColumns:{c|,b<i0>}>);
        unlock();
        return true;
    }
    public boolean groupby_update(long _pos<columns:{c|, <c.type> a<i0>}><nestedColumns:{c|, <c.type> b<i0>}>) {
        int pos = getGroupbyPos(_pos);
        long gb_offset = getGroupbyOffset(_pos);
        <getNodeAndOffset()>
        boolean success = n.nested[offset].groupby_update(gb_offset<nestedColumns:{c|, b<i0>}>);
        unlock(n);
        return success;
    }
    public void groupby_done(long _pos) {
        int pos = getGroupbyPos(_pos);
        long gb_offset = getGroupbyOffset(_pos);
        <getNodeAndOffset()>
        n.nested[offset].groupby_done(gb_offset);
        unlock(n);
    }
<else> // if (!gbNestedColumns) [
    public long groupby_getpos(<gbColumns:{c|<c.type> a<i0>};separator=", ">) {
        lock();
        <groupbyGet()>
        return pos;
    }
    public <gbAggrColumn.type> groupby_groupby(long _pos) {
        unlock();
        int pos = getGroupbyPos(_pos);
        long gb_offset = getGroupbyOffset(_pos);
        <getNodeAndOffset()>
        return n.col<gbAggrColumn.relPos>()[offset];
    }
    public boolean groupby_insert(<columns:{c|<c.type> a<i0>};separator=","><nestedColumns:{c|,<c.type> b<i0>}>) {
        insert(<columns:{c|a<i0>};separator=","><nestedColumns:{c|,b<i0>}>);
        unlock();
        return true;
    }
    public boolean groupby_update(long _pos<columns:{c|, <c.type> a<i0>}><nestedColumns:{c|, <c.type> b<i0>}>) {
        int pos = getGroupbyPos(_pos);
        <getNodeAndOffset()>
        <gbAggrColumn.type> aggr = n.col<gbAggrColumn.relPos>[offset];
    }

    public void groupby_done(long _pos) {
        int pos = getGroupbyPos(_pos);
        long gb_offset = getGroupbyOffset(_pos);
        <getNodeAndOffset()>
        n.nested[offset].groupby_done(gb_offset);
        unlock(n);
    }
<endif> // ] if (gbNestedColumns)
>>

withConsistentLen(ret, code) ::= <<
if (!readConsistencyCheckRequired) {
    <code>
    return <ret>;
}
int count = 0, maxTry = 10;
while (true) {
    int l = len;
    if (l \< 0) {
        if (count++ > maxTry) { Thread.yield();}
        continue;
    }
    <code>
    count = 0;
    if (len == l) { return <ret>; }
}
>>
withConsistentLenCopy(init, code) ::= <<
<init>
if (readConsistencyCheckRequired) {
    int count = 0, maxTry = 10;
    while (true) {
        int l = len;
        if (l \< 0) {
            if (count++ > maxTry) { Thread.yield();}
            continue;
        }
        <code>
        count = 0;
        if (len == l) { break; }
    }
}
>>
