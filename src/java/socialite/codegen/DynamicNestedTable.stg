group dynamic-nested-table;
import "TableCommon.stg"
import "DynNestTableNode.stg"

dynamicNestedTable(tableName, name, visitorClass, nestedTable, classes, methods, 
        size, id, 
        pcolumns, columns, nestedColumns, nestedNestedColumns,
        gbColumns, gbNestedColumns, gbAggrColumn,
        sortedCol, idxCols,
        concurrent=false, multiSet=false, isNested=false) ::= <<
<if(!isNested)>
package socialite.tables;

<importForTable()>
<endif>

// dynamicNestedTable
<if(!isNested)>public<endif> class <name> extends AbstractTableInst {
    private static final long serialVersionUID = 1;
    
    public static int tableid() { return <id>; }
    public static <name> create() { return new <name>(); }
    
    <nodeNest(name, pcolumns, columns, nestedColumns, sortedCol, nestedTable)>

    // XXX: if possible move to AbstractTableInst
    /** synchronization fields and methods */
    static volatile LockStatus lockStatus = LockStatus.writeLockEnabled;
    static VoidLock nolock = new VoidLock();
    static ReentrantReadWriteLock reallock = new ReentrantReadWriteLock();

    static volatile Lock writeLock = reallock.writeLock();
    static volatile Lock readLock = nolock.readLock();

    static void _enableInternalLock(boolean writeOnly) {
        writeLock = reallock.writeLock();
        if (writeOnly) {
            readLock = nolock.readLock();
            lockStatus = LockStatus.writeLockEnabled;
        } else {
            readLock = reallock.readLock();
            lockStatus = LockStatus.enabled;
        }
        <nestedTable>._enableInternalLock(writeOnly);
    }
    static void _disableInternalLock() {
        writeLock = nolock.writeLock();
        readLock = nolock.readLock();
        lockStatus = LockStatus.disabled;
    }
    static LockStatus _isLockEnabled() {
        return lockStatus;
    }

    public void enableInternalLock(boolean writeOnly) {
        _enableInternalLock(writeOnly);
    }
    public void disableInternalLock() {
        _disableInternalLock();
    }
    public LockStatus isLockEnabled() {
        return _isLockEnabled();
    }

    void wlock() { writeLock.lock(); }
    void wunlock() { writeLock.unlock(); }

    void rlock() { readLock.lock(); }
    void runlock() { readLock.unlock(); }

    // forces acquiring readlock even if only write lock is enabled (writeLockEnabled)
    void force_rlock() {
        if (lockStatus == LockStatus.writeLockEnabled) {
            reallock.readLock().lock();
        } else {
            readLock.lock();
        }
    }
    void force_runlock() {
        if (lockStatus == LockStatus.writeLockEnabled) {
            reallock.readLock().unlock();
        } else {
            readLock.unlock();
        }
    }

    TIntObjectHashMap\<SIndex> indexMap = new TIntObjectHashMap();
    IndexUtil indexUtil = new IndexUtil(this, reallock);

    SArrayList\<Node> nodeList;
    <if(idxCols)>
      <if(gbColumns && !rest(gbColumns) && first(gbColumns).indexed)>
        SIndex1 index<first(idxCols).absPos> = new SIndex1();
      <else>
        SIndex index<first(idxCols).absPos> = new SIndex();
      <endif>
    <endif>

    <rest(idxCols):{ic|SPosIndex index<ic.relPos> = new SPosIndex();<\n>}>
    <if(gbColumns)>
    <if(!rest(gbColumns) && first(gbColumns).indexed)>
        SIndex1 groupbyMap = index<first(gbColumns).absPos>;
    <else>
        SIndex1 groupbyMap = new SIndex1();
    <endif>
    <endif>

    public <name>() {
        nodeList = new SArrayList\<Node>(8);
        <idxCols:{ic|indexMap.put(<ic.absPos>, index<ic.absPos>);<\n>}>
    }


    public int id() { return <id>; }
    public int size() { assert false; return -1; }
    public String name() { return "<tableName>"; }

    public boolean isEmpty() { return nodeList.size() == 0; }
    public String toString() {
        String str="Table <tableName>(id=<id>):";
        return str + nodeList.getQuick(0).toString();
    }
    public void clearQuick() { clear(); }
    public void clear() {
        nodeList.clear();
        <idxCols:{ic|index<ic.absPos>.clear();<\n>}>
        <if(gbColumns)>groupbyMap.clear();<endif>
    }

    public boolean contains(<columns:{c|final <c.type> a<i0>};separator=", "><nestedColumns:{c|, final <c.type> b<i0>}>) {
    <if(sortedCol)>if (true) {return contains_sorted(<columns:{c|a<i0>};separator=","><nestedColumns:{c|,b<i0>}>,null);}<endif>
    <if(idxCols)>
        if (isEmpty()) { return false; }
        rlock();
        try {
            ColumnConstraints constr = new ColumnConstraints();
            <idxCols:{ic|constr.add(<ic.absPos>, a<ic.relPos>);<\n>}>
            RoaringBitmap index = indexUtil.getExclusiveIndex(indexMap, constr);
            if (index == null) { return false; }
            IntIterator iter = index.getIntIterator();
            while (iter.hasNext()) {
                int val = iter.next();
                int pos = IndexUtil.getPos(val);
                int offset = IndexUtil.getOffset(val);
                Node n = nodeList.getQuick(pos);
                if (n.contains_at(<columns:{c|a<i0>};separator=", "><nestedColumns:{c|, b<i0>}>, offset)) {
                    return true;
                }
            }
            return false;
        } finally {
            runlock();
        }
    <else>
        rlock();
        try {
            for (int i=0; i\<nodeList.size(); i++) {
                Node n = nodeList.getQuick(i);
                if (n.contains(<columns:{c|a<i0>};separator=", "><nestedColumns:{c|, b<i0>}>)) {
                    return true;
                }
            }
            return false;
        } finally {
            runlock();
        }
    <endif>
    }

    public boolean contains(<columns:{c|final <c.type> a<i0>};separator=", "><nestedColumns:{c|, final <c.type> b<i0>}>, final boolean[] dontcare) {
    <if(sortedCol)> if(dontcare==null || !dontcare[<sortedCol.relPos>]) {return contains_sorted(<columns:{c|a<i0>};separator=","><nestedColumns:{c|, b<i0>}>, dontcare);} <endif>
        if (dontcare==null) {return contains(<columns:{c|a<i0>};separator=", "><nestedColumns:{c|, b<i0>}>);}
    <if(idxCols)>
        rlock();
        using_index:
        try {
            ColumnConstraints constr = new ColumnConstraints();
            <idxCols:{ic|if(!dontcare[<ic.relPos>]){constr.add(<ic.absPos>, a<ic.relPos>);\}<\n>}>
            if (constr.isEmpty()) { break using_index; }
            RoaringBitmap index = indexUtil.getExclusiveIndex(indexMap, constr);
            if (index == null) { return false; }
            IntIterator iter = index.getIntIterator();
            while (iter.hasNext()) {
                int val = iter.next();
                int pos = IndexUtil.getPos(val);
                int offset = IndexUtil.getOffset(val);
                Node n = nodeList.getQuick(pos);
                if (n.contains_at(<columns:{c|a<i0>};separator=", "><nestedColumns:{c|, b<i0>}>, offset, dontcare)) {
                    return true;
                }
            }
            return false;
        } finally {
            runlock();
        }
    <endif>
        rlock();
        try {
            for (int i=0; i\<nodeList.size(); i++) {
                Node n = nodeList.getQuick(i);
                if (n.contains(<columns:{c|a<i0>};separator=", "><nestedColumns:{c|, b<i0>}>, dontcare)) {
                    return true;
                }
            }
            return false;
        } finally {
            runlock();
        }
    }
    void addToIndex(<idxCols:{ic|<ic.type> a<ic.relPos> ,}>int pos) {
        <idxCols:{ic|indexUtil.addIndex(index<ic.absPos>, a<ic.relPos>, pos);<\n>}>
    }
    void addToGroupbyMap(<gbColumns:{g|<g.type> a<g.relPos>,}>int pos) {
    <if(gbColumns)>
        <if(rest(gbColumns))>
            Tuple<gbColumns:{g|_<TupleMap.(g.type)>}> groupbyTup = new Tuple<gbColumns:{g|_<TupleMap.(g.type)>}>();
            <gbColumns:{g|groupbyTup._<i0> = a<i0>;}; separator="\n">
             indexUtil.addIndex(groupbyMap, groupbyTup, pos);
        <elseif(first(gbColumns).indexed)>
             assert groupbyMap == index<first(gbColumns).absPos>;
        <else>
            indexUtil.addIndex(groupbyMap, a0, pos);
        <endif>
    <endif>
    }
<if(sortedCol)>
    int binarySearch(<sortedCol.type> v, SArrayList\<Node> _nodeList) {
        if (_nodeList.size()==0) {return -1;}
        int lo=0, hi=_nodeList.size()-1;
        <sortedCol.type> midVal1, midVal2;
        while (lo \<= hi) {
            int mid = (lo+hi)/2;
            Node n = _nodeList.getQuick(mid);
            int _len = n.len();
            midVal1 = n.col<sortedCol.relPos>(0);
            midVal2 = n.col<sortedCol.relPos>(_len-1);
        <if(sortedCol.primitive)>
            if (midVal2 \< v) {lo = mid+1;}
            else if (midVal1 > v) {hi = mid-1;}
            else {return mid;}
        <else>
            if (midVal2.compareTo(v) \< 0) {lo = mid+1;}
            else if (midVal1.compareTo(v) > 0) {hi = mid-1;}
            else {return mid;}
        <endif>
        }
        if (lo == _nodeList.size()) {
            if (!_nodeList.get(lo-1).isFull()) { lo--; }
        }
        return -(lo+1);
    }
    int binarySearch1(<sortedCol.type> v, SArrayList\<Node> _nodeList) {
        int pos = binarySearch(v);
        if (pos \< 0) return pos;
        while (pos > 0) {
            pos--;
            Node n = _nodeList.getQuick(pos);
            int _len = n.len();
            if (!(n.col<sortedCol.relPos>(_len-1)<EqOpMap.(sortedCol.type)>(v))) {return pos+1;}
        }
        return pos;
    }
    int binarySearch2(<sortedCol.type> v, SArrayList\<Node> _nodeList) {
        int pos = binarySearch(v);
        if (pos \< 0) return pos;
        while (pos \< _nodeList.size()-1) {
            pos++;
            Node n = _nodeList.getQuick(pos);
            if (!(n.col<sortedCol.relPos>(0)<EqOpMap.(sortedCol.type)>(v))) {return pos-1;}
        }
        return pos;
    }
    boolean contains_sorted(<columns:{c|<c.type> a<i0>};separator=", "><nestedColumns:{c|,<c.type> b<i0>}>,boolean[] dontcare) {
        rlock();
        try {
            int pos = binarySearch1(a<sortedCol.relPos>, nodeList);
            if (pos \< 0) {return false;}
            for (int i=pos; i\<nodeList.size(); i++) {
            <if(sortedCol.primitive)>
                if (myNodeList.getQuick(i).col<sortedCol.relPos>(0) > a<sortedCol.relPos>) {return false;\}
            <else>
                if (myNodeList.getQuick(i).col<sortedCol.relPos>(0).compareTo(a<sortedCol.relPos>) > 0) {return false;\}
            <endif>
                if (nodeList.getQuick(i).contains(<columns:{c|a<i0>,}><nestedColumns:{c| b<i0>,}> dontcare)) {
                    return true;
                }
            }
            return false;
        } finally {
            runlock();
        }
    }
    boolean insert_sorted(<columns:{c|final <c.type> a<i0>};separator=", "><nestedColumns:{c|, final <c.type> b<i0>}>) {
        wlock();
    <if(!isNested && !multiSet)>
        if (contains(<columns:{c|a<i0>};separator=","><nestedColumns:{c|, b<i0>}>)) {
            wunlock();
            return false;
        }
    <endif>
        int pos = binarySearch1(a<sortedCol.relPos>, nodeList);
        boolean found = pos >= 0;
        if (found) {
            for (int i=pos; i \< nodeList.size(); i++) {
                Node n = nodeList.getQuick(pos);
            <if(sortedCol.primitive)>
                if (n.col<sortedCol.relPos>(0) > a<sortedCol.relPos>) {break;}
            <else>
                if (n.col<sortedCol.relPos>(0).compareTo(a<sortedCol.relPos>) > 0) {break;}
            <endif>
                if (n.insert_with_prefix(<columns:{c|a<i0>};separator=","><nestedColumns:{c|,b<i0>}>)) {
                    wunlock();
                    return true;
                }
            }
        }
        if (pos \< 0) { pos = -pos-1; }
        if (nodeList.size() == 0) {
            Node n = new Node$Init();
            n.insert(<columns:{c|a<i0>};separator=", "><nestedColumns:{c|,b<i0>}>);
            nodeList.add(n);
            wunlock();
        } else {
            if (pos >= nodeList.size()) { pos = nodeList.size()-1; }
            Node n = nodeList.getQuick(pos);
            n.wlock();
            if (n.isFull()) {
                Node n1 = n.copyOfRange(0, n.len()/2);
                Node n2 = n.copyOfRange(n.len()/2, n.len());
            <if(sortedCol.primitive)>
                boolean smaller = a<sortedCol.relPos> \< n2.col<sortedCol.relPos>(0);
            <else>
                boolean smaller = a<sortedCol.relPos>.compareTo(n2.col<sortedCol.relPos>(0)) \< 0;
            <endif>
                if (smaller) {
                    n1.insert(<columns:{c|a<i0>};separator=", "><nestedColumns:{c|,b<i0>}>);
                } else {
                    n2.insert(<columns:{c|a<i0>};separator=", "><nestedColumns:{c|,b<i0>}>);
                }
                nodeList.replaceWith(pos, n1, n2);
                wunlock();
                n.wunlock();
            } else {
                wunlock();
                n.insert(<columns:{c|a<i0>};separator=", "><nestedColumns:{c|,b<i0>}>);
                n.wunlock();
            }
        }
        return true;
    }
<endif> <! if(sortedCol) !>
    boolean insert_with_prefix(<columns:{c|final <c.type> a<i0>};separator=", "><nestedColumns:{c|, final <c.type> b<i0>}>) {
    <if(idxCols)>
        ColumnConstraints constr = new ColumnConstraints();
        <idxCols:{ic|constr.add(<ic.absPos>, a<ic.relPos>);<\n>}>
        RoaringBitmap index = indexUtil.getExclusiveIndex(indexMap, constr);
        do {
            if (index == null) { break; }
            IntIterator iter = index.getIntIterator();
            while (iter.hasNext()) {
                int val = iter.next();
                int pos = IndexUtil.getPos(val);
                int offset = IndexUtil.getOffset(val);
                Node n = nodeList.getQuick(pos);
                if (true<columns:{c|&&(n.col<i0>(offset)<EqOpMap.(c.type)>(a<i0>))}>) {
                    n.wlock();
                    n.nested(offset).insert(<nestedColumns:{c|b<i0>};separator=",">);
                    n.wunlock();
                    return true;
                }
            }
            return false;
        } while (false);
    <endif>
        for (int j=0; j\<nodeList.size(); j++) {
            Node n = nodeList.getQuick(j);
            for (int i=0; i\<n.len(); i++) {
                if (true<columns:{c|&&(n.col<i0>(i)<EqOpMap.(c.type)>(a<i0>))}>) {
                    n.wlock();
                    n.nested(i).insert(<nestedColumns:{c|b<i0>};separator=",">);
                    n.wunlock();
                    return true;
                }
            }
        }
        return false;
    }
    public boolean insert(<columns:{c|final <c.type> a<i0>};separator=", "><nestedColumns:{c|, final <c.type> b<i0>}>) {
    <if(sortedCol)> if (true) { return insert_sorted(<columns:{c|a<i0>};separator=", "><nestedColumns:{c|,b<i0>}>); } <endif>
        wlock();
    <if(!isNested && !multiSet)>
        if (contains(<columns:{c|a<i0>};separator=","><nestedColumns:{c|,b<i0>}>)) {
            wunlock();
            return false;
        }
    <endif>
        if (!isEmpty()) {
            boolean inserted = insert_with_prefix(<columns:{c|a<i0>};separator=", "><nestedColumns:{c|,b<i0>}>);
            if (inserted) {
                wunlock();
                return true;
            }
        }
        int offset, nodePos;
        if (nodeList.size() == 0) {
            nodePos = 0;
            Node n = new Node$Init();
            offset = n.insert(<columns:{c|a<i0>};separator=", "><nestedColumns:{c|, b<i0>}>);
            nodeList.add(n);
            wunlock();
        } else {
            Node last = nodeList.getQuick(nodeList.size()-1);
            last.wlock();
            if (last.isFull()) {
                last.wunlock();
                last = new Node();
                offset = last.insert(<columns:{c|a<i0>};separator=", "><nestedColumns:{c|, b<i0>}>);
                nodeList.add(last);
                nodePos = nodeList.size()-1;
                wunlock();
            } else {
                nodePos = nodeList.size()-1;
                wunlock();
                offset = last.insert(<columns:{c|a<i0>};separator=", "><nestedColumns:{c|, b<i0>}>);
                last.wunlock();
            }
        }
        int pos = IndexUtil.makePos(nodePos, offset);
        addToIndex(<idxCols:{ic|a<ic.relPos> ,}>pos);
        addToGroupbyMap(<gbColumns:{g|a<g.relPos>, }>pos);
        return true;
    }

<if(gbColumns)> // if (gbColumns) [
    <groupbyDynNested()>
<endif> // ] if (gbColumns)

    public void iterate(<visitorClass> v) {
        rlock();
        try {
            for (int i=0; i\<nodeList.size(); i++) {
                Node n = nodeList.getQuick(i);
                boolean cont = n.iterate(v);
                if (!cont) { return; }
            }
        } finally {
            runlock();
        }
    }

    public void iterate_by(ColumnConstraints constr, final <visitorClass> v) {
      <if(sortedCol)>
        rlock();
        try {
            if (constr.hasRange(<sortedCol.absPos>) {
                iterate_range(constr.getRange(<sortedCol.absPos>, constr, this);
            } else if (constr.hasColumn(<sortedCol.absPos>)) {
                ColumnVal colVal = constr.getColumnValue(<sortedCol.absPos>);
                <sortedCol.type> a = colVal.getValue((sortedCol.type)0);
                int nodePos = binarySearch1(a, nodeList);
                if (nodePos \< 0) { nodePos = -nodePos-1; \}
                for (int i=nodePos; i\<nodeList.size(); i++) {
                    Node n = nodeList.getQuick(i);
                    boolean cont = n.iterate_sortby(a, constr, v);
                    if (!cont) { break; }
                }
                return;
             }
         } finally { runlock(); }
      <endif>
        if (constr.getMinColumn() > <last(columns).absPos>) {
            rlock();
            try {
                for (int i=0; i\<nodeList.size(); i++) {
                    Node n = nodeList.getQuick(i);
                    boolean cont = n.iterate_by(constr, v);
                    if (!cont) { return; }
                }
            } finally {
                runlock();
            }
        } else if (constr.getMaxColumn() \< <first(columns).absPos>) {
            iterate(v);
        } else {
            indexUtil.iterateBy(indexMap, constr, v, this);
        }
    }
     public void iterate_at(ColumnConstraints _, int at, final Object o) {
        <visitorClass> v = (<visitorClass>)o;
        int nodePos =  IndexUtil.getPos(at);
        int offset = IndexUtil.getOffset(at);
        rlock();
        try {
            Node n = nodeList.getQuick(nodePos);
            n.iterate_at(_, offset, v);
        } finally {
            runlock();
        }
    }

<if(sortedCol)>
    public void iterate_range(ColumnRange range, ColumnConstraints constr, <visitorClass> v) {
        rlock();
        try {
            <sortedCol.type> from = (<sortedCol.type>)range.getFrom();
            <sortedCol.type> to = (<sortedCol.type>)range.getTo();

            int nodePos1 = binarySearch1(from, nodeList);
            if (nodePos1 \< 0) { nodePos1 = -nodePos1-1; }
            int nodePos2 = binarySearch2(to, nodeList);
            if (nodePos2 \< 0) { nodePos2 = -nodePos2-1; }
            if (nodePos2 >= nodeList.size()) { nodePos2 = nodeList.size()-1; }

            for (int i=nodePos1; i\<=nodePos2; i++) {
                Node n = nodeList.getQuick(i);
                boolean cont = n.iterate_range(from, to, constr, v);
                if (!cont) { break; }
            }
        } finally { runlock(); }
    }
<endif> <! if(sortedCol) !>

    <methods;separator="\n">
}
<classes; separator="\n">
>>

groupbyGet() ::= <<
<if(rest(gbColumns))>
    Tuple<gbColumns:{g|_<TupleMap.(g.type)>}> groupbyTup = new Tuple<gbColumns:{g|_<TupleMap.(g.type)>}>();
    <gbColumns:{g|groupbyTup._<i0> = a<i0>;}; separator="\n">
    int pos = groupbyMap.get1(groupbyTup);
<else>
    int pos = groupbyMap.get1(a0);
<endif>
>>
groupbyGet2() ::= <<
<if(rest(gbColumns))>
    pos = groupbyMap.get1(groupbyTup);
<else>
    pos = groupbyMap.get1(a0);
<endif>
>>

getNodeAndOffset() ::= <<
    int nodePos = IndexUtil.getPos(pos);
    Node n = nodeList.getQuick(nodePos);
    int offset = IndexUtil.getOffset(pos);
>>

groupbyDynNested() ::= <<
<if(nestedNestedColumns)>
    static long shiftGroupby(long pos) { return pos \<\< (64-21); }
    static long composeGroupby(int pos, long offset) { return shiftGroupby(pos)|offset; }
    static int getGroupbyPos(long pos) { return (int)(pos >\>> (64-21)); }
    static long getGroupbyOffset(long pos) { return pos & 0x000007ffffffffffL; }
<else>
    static long shiftGroupby(long pos) { return pos \<\< 21; }
    static long composeGroupby(int pos, long offset) { return shiftGroupby(pos)|offset; }
    static int getGroupbyPos(long pos) { return (int)(pos >\>> 21); }
    static long getGroupbyOffset(long pos) { return pos & 0x00000000001fffffL; }
<endif>

<if(gbNestedColumns)> // if(gbNestedColumns) [
    public boolean groupby_update(AbstractAggregation aggrFunc
                       <columns:{c|, <c.type> a<i0>}><nestedColumns:{c|,<c.type> b<i0>}>) {
        force_rlock();
        <groupbyGet()>
        if (pos \< 0) {
            force_runlock();
            wlock();
            <groupbyGet2()>
            if (pos \< 0) {
                insert(<columns:{c|a<i0>};separator=","><nestedColumns:{c|,b<i0>}>);
                wunlock();
                return true;
            } else {
                wunlock();
                // fall through to update value
            }
        } else {
            force_runlock();
        }
    // update value:
        boolean updated = false;
        <getNodeAndOffset()>
        n.wlock();
        try {
            updated = n.nested(offset).groupby_update(aggrFunc<nestedColumns:{c|, b<i0>}>);
        } finally {
            n.wunlock();
        }
        return updated;
    }

<else> // if (!gbNestedColumns) [
    public boolean groupby_update(AbstractAggregation aggrFunc
                       <columns:{c|, <c.type> a<i0>}><nestedColumns:{c|,<c.type> b<i0>}>) {
        force_rlock();
        <groupbyGet()>
        if (pos \< 0) {
            force_runlock();
            wlock();
            <groupbyGet2()>
            if (pos \< 0) {
                insert(<columns:{c|a<i0>};separator=","><nestedColumns:{c|,b<i0>}>);
                wunlock();
                return true;
            } else {
                wunlock();
                // fall through to update value
            }
        } else {
            force_runlock();
        }
    // update value:
        boolean updated = false;
        boolean equals = false;
        <getNodeAndOffset()>

    <if(gbAggrColumn.immutable)>
        n.wlock();
        <gbAggrColumn.type> oldVal = n.col<gbAggrColumn.relPos>(offset);
        equals = a<gbAggrColumn.relPos> == oldVal;
        try {
            <gbAggrColumn.type> ans = aggrFunc.apply(oldVal, a<gbAggrColumn.relPos>);
            updated = (ans != oldVal);
            if (updated) {
                n.nested(offset).clear();
                a<gbAggrColumn.relPos> = ans;
                n.update(offset<columns:{c|, a<i0>}>);
            }
            if (equals) {
                n.nested(offset).insert(<nestedColumns:{c|b<i0>};separator=",">);
            }
        } finally { n.wunlock(); }
    <else>
        n.wlock();
        <gbAggrColumn.type> oldVal = n.col<gbAggrColumn.relPos>(offset);
        equals = a<gbAggrColumn.relPos>.equals(oldVal);
        try {
            updated = aggrFunc.apply(oldVal, a<gbAggrColumn.relPos>);
            if (equals) {
                n.nested(offset).insert(<nestedColumns:{c|b<i0>};separator=",">);
            }
        } finally { n.unwlock(); }
    <endif>
    }
<endif> // ] if (gbNestedColumns)
>>
