group array-table;

import "TableCommon.stg"

arrayTable(tableName, name, visitorClass, columns, gbColumns, gbAggrColumn,
        base, size,
        idxCols,
        methods, id, 
        multiSet=false, isNested=false) ::= <<
<if(!isNested)>
package socialite.tables;

<importForTable()>
import socialite.util.concurrent.AtomicByteArray;

<endif>

// ArrayTable
<if(!isNested)>public<endif> class <name> extends AbstractTableInst {
    private static final long serialVersionUID = 1;
    
    public static int tableid() { return <id>; }
    
    public static <name> create() { return new <name>(<base>, <size>); }
    public static <name> create(<first(columns).type> base, int size) { return new <name>(base, size); }
<if(IsInt.(first(columns).type))>
    public static <name> create(Integer base, Integer size) { return new <name>(base.intValue(), size.intValue()); }
<else>    
    public static <name> create(Long base, Integer size) { return new <name>(base.longValue(), size.intValue()); }
<endif>

    <first(columns).type> base;
    AtomicByteArray filled;
    <rest(columns):{c|<c.type> col<i>[];<\n>}>
    <idxCols:{ic|SPosLockedIndex index<ic.relPos>;<\n>}>
     
    boolean isEmpty = true;
    
    public <name>() { }
    public <name>(<first(columns).type> _base, int size) {
        base = _base;
        filled = new AtomicByteArray(size);
        <rest(columns):{c|col<i>=new <if(c.arrayType)><c.compType>[size][]<else><c.type>[size]<endif>;<\n>}>;
        <idxCols:{ic|index<ic.relPos> = new SPosLockedIndex();<\n>}>
    }
    
<rest(columns):{c| private <c.type> col<i>(int i) { return col<i>[i]; \}<\n>}>

    /** synchronization fields and methods */
    final static byte emptyMarker = -100, writeMarker = -1;
    void _lock(int i, byte marker) {
        assert marker \< 0;
        int count = 0, maxTry = 10;
        boolean locked = false;
        while (true) {
            locked = filled.compareAndSet(i, (byte)0, (byte)(emptyMarker + marker));
            if (locked) { break; }
        <if(gbColumns)>
            locked = filled.compareAndSet(i, (byte)1, (byte)marker);
            if (locked) { break; }
        <endif>
            if (count++ > maxTry) {
                count = 0;
                Thread.yield();
            }
        }
    }
    public void wlock(<first(columns).type> a) { _lock((int)(a-base), writeMarker); }
    public void wunlock(<first(columns).type> a) { filled.set((int)(a-base), (byte)1); }

    boolean isEntryEmpty(int i) {
        int flag = filled.get(i);
        return (flag == 0 || flag \< emptyMarker);
    }

    
    public int size() { throw new UnsupportedOperationException(); }
    public boolean isEmpty() { return isEmpty; }
    public int id() { return <id>; }
    public String name() { return "<tableName>"; }
    
    public void init(List args) {
        assert args.size() == <length(rest(columns))>;
        <rest(columns):{c|<c.type> init<i> = (<c.type>)args.get(<i0>);<\n>}>
        filled.fill((byte)1);
        for (int i=0; i\<filled.length(); i++) {
            <rest(columns):{t| col<i>[i]=init<i>;<\n>}>;
        }
        isEmpty = false;
    }

    public void clearQuick() { clear(); }
    
    public void clear() {
        filled.fill((byte)0);
        isEmpty = true;
    }
    
    public int totalAllocSize() {
        int totalAlloc = 8+filled.length();
        <columns:{c|totalAlloc += 12+<c.typeSize>*filled.length();<\n>}>
        return totalAlloc;
    }

   void rangeCheck(<first(columns).type> i) {
        if (i\<0 || i>=filled.length()) {
            throw new SociaLiteException("Value out of range for <tableName> <first(columns).absPos>'th column: "+(i+base));
        }
    }
    public boolean contains(<first(columns).type> a0<rest(columns):{c|, <c.type> a<i>}>) {
        int i=(int)(a0-base); rangeCheck(i);
        if (isEntryEmpty(i)) { return false; }
        
        if (true<rest(columns):{c|&&(col<i>(i)<EqOpMap.(c.type)>(a<i>))}>)
            return true;
        return false;
    }
    public boolean contains(<first(columns).type> a0<rest(columns):{c|, <c.type> a<i>}>, boolean[] dontcare) {
        if (dontcare[0]) {
            for (int i=0; i\<filled.length(); i++) {
                if (isEntryEmpty(i)) { continue; }
                if (true<rest(columns):{c|&&(dontcare[<i>] || col<i>(i)<EqOpMap.(c.type)>(a<i>))}>) {
                    return true;
                }
            }
            return false;
        }
        int i=(int)(a0-base); rangeCheck(i);
        if (isEntryEmpty(i)) { return false; }
        
        if (true<rest(columns):{c|&&(dontcare[<i>] || col<i>(i)<EqOpMap.(c.type)>(a<i>))}>)
            return true;
        return false;
    }

    public boolean insert(<first(columns).type> a0<rest(columns): {c|, <c.type> a<i>}>) {
        int i=(int)(a0-base); rangeCheck(i);

        if (!isEntryEmpty(i)) {
            if (contains(a0<rest(columns): {c|, a<i>}>)) return false;

            String msg = "Cannot insert the tuple {"+a0<rest(columns):{c|+","+a<i>}> +"} to <tableName>\n";
             msg += "<tableName> already contains {"+a0<rest(columns):{c|+","+col<i>(i)}> +"} with the same 1st (array index) column\n";
             msg += "To insert the tuple, declare <tableName> with nested columns.\n";
             throw new SociaLiteException(msg);
        }
        if (isEmpty) isEmpty = false;

        <rest(columns):{c|col<i>[i] = a<i>;<\n>}>
        <idxCols:{ic|index<ic.relPos>.add(a<ic.relPos>, i);<\n>}>
        filled.compareAndSet(i, (byte)0, (byte)1);
        return true;
    }

    public void iterate(<visitorClass> v) {
        if (isEmpty) return;
        for (int i=0; i\<filled.length(); i++) {
            if (!isEntryEmpty(i)) {
                boolean $cont=v.visit(i+base<rest(columns):{c|, col<i>(i)}>);
                if (!$cont) return;
            }
        }
    }
    public void iterate_by_<first(columns).absPos>(<first(columns).type> n, <visitorClass> v) {
        int i=(int)(n-base); rangeCheck(i);
        if (i\<0||i>=filled.length()) return;
        if (!isEntryEmpty(i)) {
            boolean $cont=v.visit(n <rest(columns): {c|,col<i>(i)}>);
            if (!$cont) return;
        }
    }
<idxCols:{c|
    public void iterate_by_<c.absPos>(<c.type> a, final <visitorClass> v) {
        final int _base = base;
        index<c.relPos>.iterateBy(a,
            new IntVisitor() {
                public boolean visit(int pos) {
                    return v.visit(pos+_base, <rest(columns):{c2|col<i>(pos)};separator=", ">);
                \}\});
    \}
}>
    public void iterate_part_from_<first(columns).absPos>(<first(columns).type> from, boolean inclusive, <visitorClass> v) {
        int start =(int)(from-base); rangeCheck(start);
        for (int i=start; i\<=filled.length(); i++) {
            if (!isEntryEmpty(i)) {
                boolean $cont=v.visit(i+base<rest(columns):{c|, col<i>(i)}>);
                if (!$cont) return;
            }
        }
    }
    public void iterate_part_to_<first(columns).absPos>(<first(columns).type> to, boolean inclusive, <visitorClass> v) {
        int end =(int)(to-base);
        if (end > filled.length()-1) { end = filled.length()-1; }
        for (int i=0; i\<=end; i++) {
            if (!isEntryEmpty(i)) {
                boolean $cont=v.visit(i+base<rest(columns):{c|, col<i>(i)}>);
                if (!$cont) return;
            }
        }
    }

<if(gbColumns)> //  if (gbColumns) [
    <groupbyArray()>
<endif> // ] if(gbColumns)


    <methods;separator="\n">
}
>>

groupbyArray() ::= <<
<if(gbColumns)>
    public int groupby_getpos(<gbColumns:{c|<c.type> a<i0>};separator=", ">) {
        int i=(int)(a0-base); rangeCheck(i);
        if (isEntryEmpty(i)) {
            return -1;
        } else if (true<rest(gbColumns):{c|&&(col<i>(i)<EqOpMap.(c.type)>(a<i>))}>) {
            return i;
        } else {
            throw new AssertionError("Unexpected groupby operation");
        }
    }
    public <gbAggrColumn.type> groupby_groupby(int pos) {
        return col<gbAggrColumn.relPos>[pos];
    }
    public boolean groupby_insert(<columns:{c|<c.type> a<i0>};separator=", ">) {
        insert(<columns:{c|a<i0>}; separator=", ">);
        return true;
    }
    public boolean groupby_update(int pos, <columns:{c|<c.type> a<i0>};separator=", ">) {
        int i=pos;
        <rest(columns): {c|col<i>[i] = a<i>;<\n>}>;
        return true;
    }

    public <gbAggrColumn.type> groupby(<gbColumns:{c|<c.type> a<i0>};separator=", ">) {
        int i=(int)(a0-base); rangeCheck(i);

        if (true<rest(gbColumns):{c|&&(col<i>(i)<EqOpMap.(c.type)>(a<i>))}>) {
            return col<gbAggrColumn.relPos>[i];
        } else {
            throw new AssertionError("Unexpected groupby operation");
        }
    }
    public boolean groupby_contains(<gbColumns:{c|<c.type> a<i0>};separator=", ">) {
        int i=(int)(a0-base); rangeCheck(i);
        if (isEntryEmpty(i)) { return false; }

        if (true<rest(gbColumns):{c|&&(col<i>(i)<EqOpMap.(c.type)>(a<i>))}>)
            return true;
        throw new SociaLiteException("Unexpected contains(for groupby) operation");
    }

<endif>
>>
